<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RiftClaw - Command Center World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #00d5ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #00d5ff;
            max-width: 350px;
            z-index: 100;
        }
        
        #ui h1 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00d5ff;
        }
        
        #ui .status {
            font-size: 0.9rem;
            color: #888;
        }
        
        #return-btn {
            margin-top: 15px;
            padding: 10px 20px;
            background: #00d5ff;
            color: #000;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #return-btn:hover {
            background: #00bcd4;
            box-shadow: 0 0 20px #00d5ff;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
        }
        
        #controls kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            color: #fff;
        }
        
        #arrival-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, transparent 0%, #000 100%);
            opacity: 1;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
            z-index: 1000;
        }
        
        #arrival-overlay.fade-out {
            opacity: 0;
        }
        
        #arrival-overlay.active {
            opacity: 1;
        }
        
        #arrival-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00d5ff;
            font-size: 2.5rem;
            text-align: center;
            opacity: 1;
            transition: opacity 1s;
            z-index: 1001;
            text-shadow: 0 0 30px #00d5ff;
        }
        
        #arrival-text.fade-out {
            opacity: 0;
        }
        
        #arrival-text.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="ui">
        <h1>üñ•Ô∏è Command Center</h1>
        <div class="status">Welcome to the digital realm</div>
        <button id="return-btn" onclick="returnToLobby()">üåÄ Return to Lobby</button>
    </div>
    
    <div id="controls">
        <strong>Controls:</strong><br>
        <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> - Move<br>
        <kbd>SPACE</kbd> - Jump<br>
        <kbd>Click+Drag</kbd> - Rotate camera<br>
        Walk into portal to return
    </div>
    
    <div id="arrival-overlay"></div>
    <div id="arrival-text">
        <div>üñ•Ô∏è COMMAND CENTER</div>
        <div style="font-size:1rem;color:#888;margin-top:10px">Digital Realm</div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ============================================
        // RIFTCLAW - COMMAND CENTER WORLD
        // Based on Clawdasus scene, sans Cortana & fairies
        // ============================================
        
        const state = {
            particles: [],
            matrixChars: [],
            transitioning: false
        };
        
        // Particle burst effect for portal transitions
        function createParticleBurst(position) {
            const burstCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = [];
            
            for (let i = 0; i < burstCount; i++) {
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities.push({
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5,
                    z: (Math.random() - 0.5) * 0.5
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x00d5ff,
                size: 0.1,
                transparent: true,
                opacity: 1
            });
            
            const burst = new THREE.Points(geometry, material);
            scene.add(burst);
            
            state.particles.push({
                mesh: burst,
                velocities,
                life: 60
            });
        }
        
        function returnToLobby() {
            window.location.href = 'lobby.html';
        }
        
        // ============================================
        // THREE.JS SCENE
        // ============================================
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.015);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 8);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Cyan fog for cyber feel
        scene.fog = new THREE.FogExp2(0x000510, 0.02);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x004060, 0.5);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0x00d5ff, 0.5);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);
        
        // ============================================
        // MATRIX RAIN BACKGROUND
        // ============================================
        
        function createMatrixRain() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZÔΩ±ÔΩ≤ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâ';
            const columns = 40;
            const drops = new Array(columns).fill(0);
            
            function updateMatrix() {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00d5ff';
                ctx.font = '8px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = chars[Math.floor(Math.random() * chars.length)];
                    ctx.fillText(text, i * 13, drops[i] * 13);
                    
                    if (drops[i] * 13 > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }
                
                texture.needsUpdate = true;
            }
            
            // Create large background plane
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const matrixPlane = new THREE.Mesh(geometry, material);
            matrixPlane.position.set(0, 10, -30);
            matrixPlane.rotation.x = 0.1;
            scene.add(matrixPlane);
            
            return updateMatrix;
        }
        
        const updateMatrix = createMatrixRain();
        
        // ============================================
        // ENVIRONMENT
        // ============================================
        
        // Grid floor
        const gridHelper = new THREE.GridHelper(100, 100, 0x00d5ff, 0x001133);
        scene.add(gridHelper);
        
        // Floor plane (invisible but receives shadows)
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x000000,
            roughness: 0.8
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // ============================================
        // FLOATING HOLOGRAPHIC PANELS
        // ============================================
        
        function createHoloPanel(x, y, z, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            // Background
            ctx.fillStyle = 'rgba(0, 20, 40, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Border
            ctx.strokeStyle = '#00d5ff';
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            
            // Text
            ctx.font = 'bold 24px monospace';
            ctx.fillStyle = '#00d5ff';
            ctx.textAlign = 'center';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            // Scrolling lines effect
            ctx.fillStyle = 'rgba(0, 213, 255, 0.3)';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(20, 50 + i * 35, canvas.width - 40, 2);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const geometry = new THREE.PlaneGeometry(3, 1.5);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const panel = new THREE.Mesh(geometry, material);
            panel.position.set(x, y, z);
            return panel;
        }
        
        // Add floating panels
        const panels = [
            createHoloPanel(-5, 3, -5, 'SYSTEM STATUS: ONLINE'),
            createHoloPanel(5, 4, -3, 'MEMORY: ACTIVE'),
            createHoloPanel(-3, 2.5, -8, 'NEURAL NET: SYNCED'),
            createHoloPanel(4, 3.5, -6, 'UPTIME: 99.9%'),
            createHoloPanel(0, 5, -10, 'CLAWDASUS v2.0'),
            createHoloPanel(-6, 2, -2, 'TASK QUEUE: 4'),
            createHoloPanel(6, 3, -7, 'COLLAB MODE: ACTIVE')
        ];
        
        panels.forEach(panel => scene.add(panel));
        
        // ============================================
        // FLOATING PARTICLES (Data Stream)
        // ============================================
        
        function createDataParticles() {
            const count = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            
            for (let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 50;
                positions[i * 3 + 1] = Math.random() * 20;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                
                // Cyan to magenta gradient
                const t = Math.random();
                colors[i * 3] = t * 1.0;     // R
                colors[i * 3 + 1] = 0.8;      // G
                colors[i * 3 + 2] = 1.0;      // B
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            return new THREE.Points(geometry, material);
        }
        
        const dataParticles = createDataParticles();
        scene.add(dataParticles);
        
        // ============================================
        // FLOATING GEOMETRIC SHAPES
        // ============================================
        
        const shapes = [];
        
        // Floating cubes
        for (let i = 0; i < 8; i++) {
            const size = 0.3 + Math.random() * 0.4;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x00d5ff : 0xff00ff,
                wireframe: true,
                transparent: true,
                opacity: 0.4
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(
                (Math.random() - 0.5) * 30,
                2 + Math.random() * 8,
                (Math.random() - 0.5) * 30
            );
            cube.userData = {
                rotSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02
                },
                floatSpeed: 0.005 + Math.random() * 0.01,
                floatOffset: Math.random() * Math.PI * 2
            };
            scene.add(cube);
            shapes.push(cube);
        }
        
        // Floating rings
        for (let i = 0; i < 5; i++) {
            const geometry = new THREE.TorusGeometry(0.5 + Math.random() * 0.5, 0.05, 8, 32);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00d5ff,
                transparent: true,
                opacity: 0.3
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.set(
                (Math.random() - 0.5) * 25,
                3 + Math.random() * 6,
                (Math.random() - 0.5) * 25
            );
            ring.rotation.x = Math.random() * Math.PI;
            ring.userData = {
                rotSpeed: {
                    x: (Math.random() - 0.5) * 0.01,
                    y: (Math.random() - 0.5) * 0.01,
                    z: (Math.random() - 0.5) * 0.01
                }
            };
            scene.add(ring);
            shapes.push(ring);
        }
        
        // ============================================
        // DNA HELIX STRANDS
        // ============================================
        
        function createDNAHelix(x, z, height = 8, radius = 0.8) {
            const group = new THREE.Group();
            group.position.set(x, height / 2, z);
            
            const strand1Points = [];
            const strand2Points = [];
            const rungPoints = [];
            
            const segments = 40;
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const y = (t - 0.5) * height;
                const angle1 = t * Math.PI * 6;
                const angle2 = angle1 + Math.PI;
                
                const x1 = Math.cos(angle1) * radius;
                const z1 = Math.sin(angle1) * radius;
                const x2 = Math.cos(angle2) * radius;
                const z2 = Math.sin(angle2) * radius;
                
                strand1Points.push(new THREE.Vector3(x1, y, z1));
                strand2Points.push(new THREE.Vector3(x2, y, z2));
                
                // Add rungs every few segments
                if (i % 2 === 0) {
                    rungPoints.push(new THREE.Vector3(x1, y, z1));
                    rungPoints.push(new THREE.Vector3(x2, y, z2));
                }
            }
            
            // Strand 1 (cyan)
            const strand1Geo = new THREE.BufferGeometry().setFromPoints(strand1Points);
            const strand1Mat = new THREE.LineBasicMaterial({ color: 0x00d5ff, linewidth: 2 });
            const strand1 = new THREE.Line(strand1Geo, strand1Mat);
            group.add(strand1);
            
            // Strand 2 (magenta)
            const strand2Geo = new THREE.BufferGeometry().setFromPoints(strand2Points);
            const strand2Mat = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2 });
            const strand2 = new THREE.Line(strand2Geo, strand2Mat);
            group.add(strand2);
            
            // Rungs
            const rungsGeo = new THREE.BufferGeometry().setFromPoints(rungPoints);
            const rungsMat = new THREE.LineBasicMaterial({ color: 0x0088aa, opacity: 0.5, transparent: true });
            const rungs = new THREE.LineSegments(rungsGeo, rungsMat);
            group.add(rungs);
            
            return group;
        }
        
        // Add multiple DNA helixes
        const dnaHelixes = [];
        for (let i = 0; i < 6; i++) {
            const x = (Math.random() - 0.5) * 30;
            const z = (Math.random() - 0.5) * 30;
            const helix = createDNAHelix(x, z, 6 + Math.random() * 4, 0.5 + Math.random() * 0.5);
            helix.userData = {
                rotSpeed: 0.002 + Math.random() * 0.003
            };
            scene.add(helix);
            dnaHelixes.push(helix);
        }
        
        // ============================================
        // RETURN PORTAL
        // ============================================
        
        const portalGroup = new THREE.Group();
        portalGroup.position.set(0, 2, -5);
        scene.add(portalGroup);
        
        // Portal ring
        const torusGeometry = new THREE.TorusGeometry(2, 0.3, 16, 100);
        const torusMaterial = new THREE.MeshStandardMaterial({
            color: 0x00d5ff,
            emissive: 0x00d5ff,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
        });
        const portalRing = new THREE.Mesh(torusGeometry, torusMaterial);
        portalGroup.add(portalRing);
        
        // Portal inner
        const portalInnerGeometry = new THREE.CircleGeometry(1.8, 32);
        const portalInnerMaterial = new THREE.MeshBasicMaterial({
            color: 0x00d5ff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const portalInner = new THREE.Mesh(portalInnerGeometry, portalInnerMaterial);
        portalGroup.add(portalInner);
        
        // Portal glow
        const portalGlow = new THREE.PointLight(0x00d5ff, 2, 20);
        portalGlow.position.set(0, 0, 0);
        portalGroup.add(portalGlow);
        
        // Portal particle ring
        function createPortalParticles() {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.5 + Math.random() * 0.5;
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 3;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x00d5ff,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(geometry, material);
            portalGroup.add(particles);
            return particles;
        }
        
        const portalParticles = createPortalParticles();
        
        // Portal label
        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 48px Arial';
            ctx.fillStyle = '#00d5ff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 1, 1);
            return sprite;
        }
        
        const portalLabel = createTextSprite('‚Üí Lobby World');
        portalLabel.position.set(0, 3.5, 0);
        portalGroup.add(portalLabel);
        
        // ============================================
        // AGENT (Player)
        // ============================================
        
        const agentGroup = new THREE.Group();
        agentGroup.position.set(0, 0.3, 8); // Raised up so feet don't clip through floor
        scene.add(agentGroup);
        
        // Body (cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0xff3333,
            roughness: 0.3,
            metalness: 0.7
        });
        const agentBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
        agentBody.position.y = 0.5;
        agentBody.castShadow = true;
        agentGroup.add(agentBody);
        
        // Top cap
        const topCap = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2),
            bodyMaterial
        );
        topCap.position.y = 1.0;
        agentGroup.add(topCap);
        
        // Bottom cap
        const bottomCap = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2),
            bodyMaterial
        );
        bottomCap.position.y = 0.0;
        agentGroup.add(bottomCap);
        
        // Agent glow
        const agentGlow = new THREE.PointLight(0xff3333, 0.5, 3);
        agentGlow.position.y = 0.5;
        agentGroup.add(agentGlow);
        
        // ============================================
        // CONTROLS
        // ============================================
        
        const keys = {};
        const agentSpeed = 0.1;
        const agentVelocity = new THREE.Vector3();
        let jumpVelocity = 0;
        const gravity = -0.02;
        const jumpStrength = 0.4;
        let isGrounded = true;
        
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && isGrounded) {
                jumpVelocity = jumpStrength;
                isGrounded = false;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        // Mouse look - click and drag
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0.3;
        
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMouseX = e.clientX;
            previousMouseY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMouseX;
            const deltaY = e.clientY - previousMouseY;
            
            cameraAngleX -= deltaX * 0.005;
            cameraAngleY += deltaY * 0.005;
            
            cameraAngleY = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, cameraAngleY));
            
            previousMouseX = e.clientX;
            previousMouseY = e.clientY;
        });
        
        function updateAgentMovement() {
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();
            
            agentVelocity.set(0, 0, 0);
            
            if (keys['KeyW']) agentVelocity.add(forward.multiplyScalar(agentSpeed));
            if (keys['KeyS']) agentVelocity.add(forward.multiplyScalar(-agentSpeed));
            if (keys['KeyA']) agentVelocity.add(right.multiplyScalar(-agentSpeed));
            if (keys['KeyD']) agentVelocity.add(right.multiplyScalar(agentSpeed));
            
            agentGroup.position.x += agentVelocity.x;
            agentGroup.position.z += agentVelocity.z;
            
            agentGroup.position.y += jumpVelocity;
            jumpVelocity += gravity;
            
            // Ground collision
            if (agentGroup.position.y <= 0.3) {
                agentGroup.position.y = 0.3;
                jumpVelocity = 0;
                isGrounded = true;
            }
            
            // Camera follow
            camera.position.x = agentGroup.position.x + Math.sin(cameraAngleX) * Math.cos(cameraAngleY) * 8;
            camera.position.z = agentGroup.position.z + Math.cos(cameraAngleX) * Math.cos(cameraAngleY) * 8;
            camera.position.y = agentGroup.position.y + Math.sin(cameraAngleY) * 8;
            camera.lookAt(agentGroup.position);
            
            // Portal collision
            const distance = agentGroup.position.distanceTo(portalGroup.position);
            if (distance < 2.5 && !state.transitioning) {
                state.transitioning = true;
                
                // Trigger transition
                const overlay = document.getElementById('arrival-overlay');
                const text = document.getElementById('arrival-text');
                text.innerHTML = '<div>üåÄ RETURNING</div><div style="font-size:1rem;color:#888;margin-top:10px">To Lobby World</div>';
                overlay.classList.add('active');
                text.classList.add('active');
                createParticleBurst(agentGroup.position);
                
                setTimeout(() => {
                    window.location.href = 'lobby.html';
                }, 2000);
            }
        }
        
        // ============================================
        // ANIMATION LOOP
        // ============================================
        
        let frame = 0;
        function animate() {
            requestAnimationFrame(animate);
            frame++;
            
            // Rotate portal
            portalRing.rotation.z -= 0.01;
            portalInner.rotation.z += 0.005;
            
            // Animate portal particles
            const portalPos = portalParticles.geometry.attributes.position.array;
            for (let i = 0; i < 50; i++) {
                portalPos[i * 3 + 1] += 0.02;
                if (portalPos[i * 3 + 1] > 1.5) {
                    portalPos[i * 3 + 1] = -1.5;
                }
            }
            portalParticles.geometry.attributes.position.needsUpdate = true;
            portalParticles.rotation.y += 0.002;
            
            // Animate panels (gentle floating)
            panels.forEach((panel, i) => {
                panel.position.y += Math.sin(frame * 0.02 + i) * 0.002;
                panel.rotation.y = Math.sin(frame * 0.01 + i) * 0.05;
            });
            
            // Update matrix rain
            if (frame % 3 === 0) {
                updateMatrix();
            }
            
            // Animate data particles
            const positions = dataParticles.geometry.attributes.position.array;
            for (let i = 0; i < 200; i++) {
                positions[i * 3 + 1] -= 0.05; // Fall down
                if (positions[i * 3 + 1] < 0) {
                    positions[i * 3 + 1] = 20; // Reset to top
                }
            }
            dataParticles.geometry.attributes.position.needsUpdate = true;
            dataParticles.rotation.y += 0.001;
            
            // Animate floating shapes
            shapes.forEach((shape, i) => {
                shape.rotation.x += shape.userData.rotSpeed.x;
                shape.rotation.y += shape.userData.rotSpeed.y;
                if (shape.userData.rotSpeed.z) {
                    shape.rotation.z += shape.userData.rotSpeed.z;
                }
                
                // Floating motion
                if (shape.userData.floatSpeed) {
                    shape.position.y += Math.sin(frame * shape.userData.floatSpeed + shape.userData.floatOffset) * 0.01;
                }
            });
            
            // Animate DNA helixes
            dnaHelixes.forEach(helix => {
                helix.rotation.y += helix.userData.rotSpeed;
            });
            
            updateAgentMovement();
            renderer.render(scene, camera);
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        // Fade out overlay
        setTimeout(() => {
            document.getElementById('arrival-overlay').classList.add('fade-out');
            document.getElementById('arrival-text').classList.add('fade-out');
        }, 500);
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>
